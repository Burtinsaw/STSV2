class RealDocumentService {
  constructor() {
    this.openaiApiKey = import.meta.env?.VITE_OPENAI_API_KEY || '';
    this.geminiApiKey = import.meta.env?.VITE_GEMINI_API_KEY || '';
    this.googleApiKey = import.meta.env?.VITE_GOOGLE_API_KEY || '';
    
    if (import.meta.env?.DEV) {
      console.log('üîë API Keys durumu:', {
        openai: this.openaiApiKey ? '‚úÖ Var' : '‚ùå Yok',
        gemini: this.geminiApiKey ? '‚úÖ Var' : '‚ùå Yok',
        google: this.googleApiKey ? '‚úÖ Var' : '‚ùå Yok'
      });
    }
  }

  getAIProvider() {
    if (this.geminiApiKey) return 'gemini';
    if (this.openaiApiKey) return 'openai';
    return 'pattern';
  }

  async extractProductsWithGemini(text) {
    try {
      if (!this.geminiApiKey) {
        throw new Error('Gemini API key bulunamadƒ±');
      }

      console.log('ü§ñ Gemini ile √ºr√ºn √ßƒ±karma...');
      
      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${this.geminiApiKey}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: `A≈üaƒüƒ±daki metinden √ºr√ºnleri JSON formatƒ±nda √ßƒ±kar. Sadece JSON array d√∂nd√ºr:
              
              Gerekli alanlar:
              - name: √úr√ºn adƒ± (zorunlu)
              - quantity: Miktar (sayƒ±, zorunlu)
              - unit: Birim (zorunlu)
              - brand: Marka
              - model: Model
              - description: A√ßƒ±klama
              - estimatedPrice: Tahmini fiyat (sayƒ±)
              - currency: Para birimi
              
              Metin:
              ${text}`
            }]
          }]
        })
      });

      if (!response.ok) {
        throw new Error(`Gemini API hatasƒ±: ${response.status}`);
      }

      const data = await response.json();
      const content = data.candidates[0].content.parts[0].text;
      
      // JSON parse et
      const jsonMatch = content.match(/\[[\s\S]*\]/);
      if (jsonMatch) {
        const products = JSON.parse(jsonMatch[0]);
        console.log('‚úÖ Gemini sonucu:', products.length, '√ºr√ºn');
        return products.map((p, i) => ({
          ...p,
          id: i + 1,
          source: 'gemini-ai'
        }));
      }
      return [];
    } catch (error) {
      console.error('‚ùå Gemini hatasƒ±:', error);
      throw error;
    }
  }

  async extractProductsWithOpenAI(text) {
    try {
      if (!this.openaiApiKey) {
        throw new Error('OpenAI API key bulunamadƒ±');
      }

      console.log('üß† OpenAI ile √ºr√ºn √ßƒ±karma...');
      
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.openaiApiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: 'gpt-4',
          messages: [{
            role: 'system',
            content: `Sen bir √ºr√ºn √ßƒ±karma uzmanƒ±sƒ±n. Verilen metinden √ºr√ºn listesi √ßƒ±kar ve JSON formatƒ±nda d√∂nd√ºr.
            
            Gerekli alanlar:
            - name: √úr√ºn adƒ± (zorunlu)
            - quantity: Miktar (sayƒ±, zorunlu)
            - unit: Birim (zorunlu)
            - brand: Marka
            - model: Model
            - description: A√ßƒ±klama
            - estimatedPrice: Tahmini fiyat (sayƒ±)
            - currency: Para birimi
            
            Sadece JSON array d√∂nd√ºr, ba≈üka a√ßƒ±klama yapma.`
          }, {
            role: 'user',
            content: `Bu metinden √ºr√ºnleri √ßƒ±kar: ${text}`
          }],
          temperature: 0.3,
          max_tokens: 2000
        })
      });

      if (!response.ok) {
        throw new Error(`OpenAI API hatasƒ±: ${response.status}`);
      }

      const data = await response.json();
      const content = data.choices[0].message.content;
      const products = JSON.parse(content);
      
      console.log('‚úÖ OpenAI sonucu:', products.length, '√ºr√ºn');
      return products.map((p, i) => ({
        ...p,
        id: i + 1,
        source: 'openai-gpt4'
      }));
    } catch (error) {
      console.error('‚ùå OpenAI hatasƒ±:', error);
      throw error;
    }
  }

  extractProductsWithPattern(text) {
    console.log('üîç Pattern matching ile √ºr√ºn √ßƒ±karma...');
    
    const products = [];
    const lines = text.split('\n');
    
    const patterns = [
      /(\d+)\s*[x√ó]\s*(.+?)(?:\s+(\d+(?:[.,]\d+)?)\s*(TL|USD|EUR|‚Ç∫|\$|‚Ç¨|‚ÇΩ))?/gi,
      /(.+?)\s*[-‚Äì]\s*(\d+)\s*(adet|pcs|pieces|units?|—à—Ç)(?:\s+(\d+(?:[.,]\d+)?)\s*(TL|USD|EUR|‚Ç∫|\$|‚Ç¨|‚ÇΩ))?/gi,
      /\d+[.)]\s*(.+?)(?:\s+(\d+)\s*(adet|pcs|—à—Ç)?)?(?:\s+(\d+(?:[.,]\d+)?)\s*(TL|USD|EUR|‚Ç∫|\$|‚Ç¨|‚ÇΩ))?/gi
    ];
    
    lines.forEach((line, index) => {
      const trimmedLine = line.trim();
      if (trimmedLine.length < 3) return;
      
      patterns.forEach(pattern => {
        const matches = [...trimmedLine.matchAll(pattern)];
        matches.forEach(match => {
          let product;
          if (pattern.source.startsWith(String.raw`(\d+)`)) {
            product = {
              name: match[2]?.trim() || '',
              quantity: parseInt(match[1]) || 1,
              unit: 'adet',
              estimatedPrice: match[3] ? parseFloat(match[3].replace(',', '.')) : 0,
              currency: match[4] || 'TL',
              source: 'pattern-1'
            };
          } else if (pattern.source.includes('[-‚Äì]')) {
            product = {
              name: match[1]?.trim() || '',
              quantity: parseInt(match[2]) || 1,
              unit: match[3] || 'adet',
              estimatedPrice: match[4] ? parseFloat(match[4].replace(',', '.')) : 0,
              currency: match[5] || 'TL',
              source: 'pattern-2'
            };
          } else {
            product = {
              name: match[1]?.trim() || '',
              quantity: match[2] ? parseInt(match[2]) : 1,
              unit: match[3] || 'adet',
              estimatedPrice: match[4] ? parseFloat(match[4].replace(',', '.')) : 0,
              currency: match[5] || 'TL',
              source: 'pattern-3'
            };
          }
          
          if (product.name && product.name.length > 2) {
            product.description = trimmedLine;
            product.lineNumber = index + 1;
            products.push(product);
          }
        });
      });
    });
    
    // Benzersiz √ºr√ºnleri filtrele
    const uniqueProducts = [];
    const seen = new Set();
    products.forEach(product => {
      const key = `${product.name.toLowerCase()}-${product.quantity}`;
      if (!seen.has(key)) {
        seen.add(key);
        uniqueProducts.push(product);
      }
    });
    
    console.log('‚úÖ Pattern matching sonucu:', uniqueProducts.length, '√ºr√ºn');
    return uniqueProducts;
  }

  async detectLanguage(text) {
    try {
      if (this.googleApiKey) {
        console.log('üîç Google Translate ile dil algƒ±lama...');
        
        const response = await fetch('https://translation.googleapis.com/language/translate/v2/detect', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            key: this.googleApiKey,
            q: text.substring(0, 1000)
          })
        });

        if (response.ok) {
          const data = await response.json();
          const detectedLang = data.data.detections[0][0].language;
          console.log('‚úÖ Algƒ±lanan dil:', detectedLang);
          return detectedLang;
        }
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Google dil algƒ±lama hatasƒ±:', error);
    }

    // Fallback: Pattern matching ile dil algƒ±lama
    const rusChars = /[–∞-—è–ê-–Ø]/g;
    const engChars = /[a-zA-Z]/g;
    const trChars = /[√ßƒüƒ±√∂≈ü√º√áƒûƒ∞√ñ≈û√ú]/g;
    
    const rusCount = (text.match(rusChars) || []).length;
    const engCount = (text.match(engChars) || []).length;
    const trCount = (text.match(trChars) || []).length;
    
    if (rusCount > engCount && rusCount > trCount) return 'ru';
    if (trCount > engCount) return 'tr';
    return 'en';
  }

  async translateText(text, sourceLang, targetLang) {
    if (sourceLang === targetLang) return text;
    
    try {
      if (this.googleApiKey) {
        console.log(`üåê Google Translate ile √ßeviri: ${sourceLang} ‚Üí ${targetLang}`);
        
        const response = await fetch('https://translation.googleapis.com/language/translate/v2', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            key: this.googleApiKey,
            q: text,
            source: sourceLang,
            target: targetLang,
            format: 'text'
          })
        });

        if (response.ok) {
          const data = await response.json();
          const translatedText = data.data.translations[0].translatedText;
          console.log('‚úÖ √áeviri tamamlandƒ±');
          return translatedText;
        }
      }
    } catch (error) {
      console.error('‚ùå Google Translate hatasƒ±:', error);
    }

    // Fallback: Basit kelime √ßevirisi
    const translations = {
      'en-tr': {
        'Product List': '√úr√ºn Listesi',
        'Quantity': 'Miktar',
        'Price': 'Fiyat',
        'Unit': 'Birim',
        'Description': 'A√ßƒ±klama'
      },
      'ru-tr': {
        '–°–ø–∏—Å–æ–∫ —Ç–æ–≤–∞—Ä–æ–≤': '√úr√ºn Listesi',
        '–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ': 'Miktar',
        '–¶–µ–Ω–∞': 'Fiyat',
        '–ï–¥–∏–Ω–∏—Ü–∞': 'Birim',
        '–û–ø–∏—Å–∞–Ω–∏–µ': 'A√ßƒ±klama',
        '–ê–≤—Ç–æ–º–∞—Ç—ã': 'Otomatlar',
        'SCHNEIDER': 'SCHNEIDER',
        '–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ': 'miktar',
        '—Ü–µ–Ω–∞': 'fiyat',
        '—Ä—É–±–ª—å': 'ruble',
        '–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞': '√úr√ºn Adƒ±',
        '–ù–∞–∑–≤–∞–Ω–∏–µ –º–æ–¥–µ–ª–∏': 'Model Adƒ±',
        '–ñ–µ–ª–∞–µ–º—ã–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å': 'ƒ∞stenen √úretici',
        '–ö–æ–ª-–≤–æ': 'Miktar',
        '–¶–µ–Ω–∞': 'Fiyat'
      }
    };
    
    let translated = text;
    const langPair = `${sourceLang}-${targetLang}`;
    if (translations[langPair]) {
      Object.entries(translations[langPair]).forEach(([key, value]) => {
        translated = translated.replace(new RegExp(key, 'gi'), value);
      });
    }
    
    return translated;
  }

  async parseExcelFile(file) {
    try {
      console.log('üìä Excel parsing ba≈ülatƒ±lƒ±yor...');
      
      // Dynamically import xlsx library
      const XLSX = await import('xlsx');
      
      const arrayBuffer = await file.arrayBuffer();
      const workbook = XLSX.read(arrayBuffer, { type: 'array' });
      const firstSheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[firstSheetName];
      
      const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
      
      console.log('üìä Excel satƒ±r sayƒ±sƒ±:', jsonData.length);
      
      const products = [];
      const headers = jsonData[0] || [];
      
      for (let i = 1; i < jsonData.length; i++) {
        const row = jsonData[i];
        if (!row || row.length === 0) continue;
        
        const product = {
          id: i,
          name: row[1] || row[0] || '',
          brand: row[3] || '',
          model: row[2] || '',
          quantity: parseInt(row[4]) || 1,
          unit: 'adet',
          estimatedPrice: parseFloat(row[6]) || 0,
          currency: '‚ÇΩ',
          source: 'excel',
          description: row.join(' - ')
        };
        
        if (product.name && product.name.length > 2) {
          products.push(product);
        }
      }
      
      console.log('‚úÖ Excel\'den √ßƒ±karƒ±lan √ºr√ºn sayƒ±sƒ±:', products.length);
      
      const text = jsonData.map(row => row.join('\t')).join('\n');
      return { text, products };
    } catch (error) {
      console.error('‚ùå Excel parsing hatasƒ±:', error);
      throw new Error(`Excel dosyasƒ± i≈ülenemedi: ${error.message}`);
    }
  }

  async parsePdfFile(file) {
    try {
      console.log('üìÑ PDF parsing ba≈ülatƒ±lƒ±yor...');
      
      // Dynamically import pdfjs-dist
      const pdfjsLib = await import('pdfjs-dist/build/pdf.min.mjs');
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
      
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      
      let text = '';
      for (let i = 1; i <= Math.min(pdf.numPages, 10); i++) {
        const page = await pdf.getPage(i);
        const textContent = await page.getTextContent();
        text += textContent.items.map(item => item.str).join(' ') + '\n';
      }
      
      console.log('‚úÖ PDF metin √ßƒ±karƒ±ldƒ±, uzunluk:', text.length);
      return text;
    } catch (error) {
      console.error('‚ùå PDF parsing hatasƒ±:', error);
      return `PDF DOSYASI TESPƒ∞T EDƒ∞LDƒ∞

Bu bir PDF dosyasƒ±dƒ±r. ƒ∞√ßeriƒüi okumak i√ßin:

1. üìÇ PDF dosyasƒ±nƒ± a√ßƒ±n
2. üîç Ctrl+A ile t√ºm i√ßeriƒüi se√ßin
3. üìã Ctrl+C ile kopyalayƒ±n  
4. üìù A≈üaƒüƒ±daki √ßeviri alanƒ±na Ctrl+V ile yapƒ±≈ütƒ±rƒ±n
5. üîÑ "√áevir ve √úr√ºnleri √áƒ±kar" butonuna tƒ±klayƒ±n

Alternatif: PDF'i Excel'e d√∂n√º≈üt√ºr√ºp y√ºkleyebilirsiniz.`;
    }
  }

  async parseImageFile(file) {
    try {
      console.log('üñºÔ∏è OCR i≈ülemi ba≈ülatƒ±lƒ±yor...');
      
      // Dynamically import tesseract.js
      const Tesseract = await import('tesseract.js');
      
      const result = await Tesseract.recognize(
        file,
        'tur+eng+rus',
        { logger: m => console.log(m) }
      );
      
      console.log('‚úÖ OCR tamamlandƒ±, metin uzunluƒüu:', result.data.text.length);
      return result.data.text;
    } catch (error) {
      console.error('‚ùå OCR hatasƒ±:', error);
      return `RESƒ∞M DOSYASI TESPƒ∞T EDƒ∞LDƒ∞

OCR i≈ülemi i√ßin Tesseract.js k√ºt√ºphanesi gerekli.

Manuel i≈ülem:
1. üñºÔ∏è Resmi a√ßƒ±n
2. üìù ƒ∞√ßeriƒüi manuel olarak yazƒ±n
3. üìã A≈üaƒüƒ±daki √ßeviri alanƒ±na yapƒ±≈ütƒ±rƒ±n
4. üîÑ "√áevir ve √úr√ºnleri √áƒ±kar" butonuna tƒ±klayƒ±n`;
    }
  }

  async parseWordFile(file) {
    const text = await file.text();
    
    // Binary i√ßerik kontrol√º
    if (text.includes('word/') || text.includes('PK') || text.includes('xml')) {
      console.warn('üìÑ DOCX binary i√ßeriƒüi tespit edildi');
      return `DOCX DOSYASI TESPƒ∞T EDƒ∞LDƒ∞

Bu bir Word belgesi (.docx) dosyasƒ±dƒ±r. ƒ∞√ßeriƒüi okumak i√ßin:

1. üìÇ Word belgesini a√ßƒ±n
2. üîç Ctrl+A ile t√ºm i√ßeriƒüi se√ßin  
3. üìã Ctrl+C ile kopyalayƒ±n
4. üìù A≈üaƒüƒ±daki √ßeviri alanƒ±na Ctrl+V ile yapƒ±≈ütƒ±rƒ±n
5. üîÑ "√áevir ve √úr√ºnleri √áƒ±kar" butonuna tƒ±klayƒ±n

Bu ≈üekilde i√ßerik AI sistemi ile i≈ülenecektir.`;
    }
    
    return text;
  }

  async processFile(file) {
    try {
      console.log('üìÅ Dosya i≈üleme ba≈ülatƒ±lƒ±yor...');
      
      let text = '';
      let products = [];
      
      if (file.type.includes('image')) {
        text = await this.parseImageFile(file);
      } else if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {
        const result = await this.parseExcelFile(file);
        text = result.text;
        products = result.products;
      } else if (file.name.endsWith('.pdf')) {
        text = await this.parsePdfFile(file);
      } else if (file.name.endsWith('.docx') || file.name.endsWith('.doc')) {
        text = await this.parseWordFile(file);
      } else {
        text = await file.text();
      }
      
      return { text, products };
    } catch (error) {
      console.error('üí• Dosya i≈üleme hatasƒ±:', error);
      throw error;
    }
  }

  async extractProductsWithAI(text, provider = this.getAIProvider()) {
    if (provider === 'gemini' && this.geminiApiKey) {
      return await this.extractProductsWithGemini(text);
    } else if (provider === 'openai' && this.openaiApiKey) {
      return await this.extractProductsWithOpenAI(text);
    } else {
      return this.extractProductsWithPattern(text);
    }
  }
}

// Singleton instance
const realDocumentService = new RealDocumentService();

export default realDocumentService;